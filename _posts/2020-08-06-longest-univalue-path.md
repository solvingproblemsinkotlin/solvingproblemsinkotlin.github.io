---
layout: post
title:  "Longest Univalue Path"
date:   2020-08-06 09:45:12 +0200
categories:
  - Easy
tags:
  - tree
  - recursion
---
Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.

The length of path between two nodes is represented by the number of edges between them.

## Example 1:

Input:
{% highlight kotlin %}

       5
      / \
     4   5
    / \   \
   1   1   5

#=> Output: 2
#=> Path: 5 - 5 - 5
{% endhighlight %}

## Example 2:

{% highlight kotlin %}

       1
      / \
     4   5
    / \   \
   4   4   5

#=> Output: 2
#=> Path: 4 - 4 - 4
{% endhighlight %}

# Solution

Using a recursive function to traverse all nodes in the tree, updating the longest path found between nodes with same values.

{% highlight kotlin %}
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */

class Solution {

    var longestPath = 0

    fun longestUnivaluePath(root: TreeNode?): Int {
        longestPath = 0
        longestUnivaluePathFrom(root)
        return longestPath
    }

    private fun longestUnivaluePathFrom(root: TreeNode?): Int {
        if (root == null)
            return 0

        var leftLength = longestUnivaluePathFrom(root.left)
        var rightLength = longestUnivaluePathFrom(root.right)
        if (root.left != null && root.left?.`val` === root.`val`) {
            leftLength++
        } else {
            leftLength = 0
        }
        if (root.right != null && root.right?.`val` === root.`val`) {
            rightLength++
        } else {
            rightLength = 0
        }

        longestPath = Math.max(longestPath, leftLength + rightLength)

        return Math.max(leftLength, rightLength)
    }

}
{% endhighlight %}

## Complexity Analysis

_Time Complexity_: O(N), where N is the number of nodes in the tree. We process every node once.

_Space Complexity_: O(H), where H is the height of the tree. Our recursive call stack could be up to HH layers deep.

# Let's analyze the code

We call a recursive function which is going to update the longest path value found between nodes with similar values. This function will return an Int representing the longest path found in this subtree. In this function:

We check our base condition: If your node is null, return 0. This means either you have no tree at all (root node is null) or you're out of the tree.

{% highlight kotlin %}
if (root == null)
    return 0
{% endhighlight %}

We are calling the recursive function both for the subtree generated by our left and right nodes. Thus, we are getting the longest paths found in each subtree.

{% highlight kotlin %}
var leftLength = longestUnivaluePathFrom(root.left)
var rightLength = longestUnivaluePathFrom(root.right)
{% endhighlight %}

In case the value of root is similar to one of its children (left or right nodes), we are incrementing the longest path retrieved by the previous calls to the recursive function.

In case the value is not the same or if any children is null, we are setting the longest path to 0. There is no path.
{% highlight kotlin %}
if (root.left != null && root.left?.`val` === root.`val`) {
    leftLength++
} else {
    leftLength = 0
}
if (root.right != null && root.right?.`val` === root.`val`) {
    rightLength++
} else {
    rightLength = 0
}
{% endhighlight %}

This piece of code may be the most controversial. In here, we are updating the longest path only if the path retrieved by the left node plus the path retrieved by the right node is greater than the current longest path.
{% highlight kotlin %}
longestPath = Math.max(longestPath, leftLength + rightLength)
{% endhighlight %}

This is easier to understand using the second example:

{% highlight kotlin %}

       1
      / \
     4   5
    / \   \
   4   4   5

#=> leftLength = 1
#=> rightLength = 1
#=> longestPath = Math.max(longestPath, leftLength + rightLength)
#=> longestPath = 2
#=> Path: 4 - 4 - 4
{% endhighlight %}

Finally, we are returning the longest path found at the end of the recursive function
{% highlight kotlin %}
return Math.max(leftLength, rightLength)
{% endhighlight %}
